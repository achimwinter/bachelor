\documentclass[12pt,oneside,a4paper,parskip]{scrbook}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage[T1]{fontenc}
\usepackage{floatflt}
\usepackage{subfigure}
\usepackage[pdftex]{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{color}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage{nicefrac}
\usepackage{scrhack}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{subfigure}
\usepackage{pdfpages}
\usepackage[verbose]{placeins}
\usepackage[markcase=ignoreuppercase,headsepline,plainfootsepline]{scrlayer-scrpage}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{epstopdf}
\usepackage{longtable}
\newlength\colw
\usepackage{booktabs}
\usepackage{nameref}
\usepackage[
backend=biber,
style=apa,
citestyle=authoryear-comp
]{biblatex}
\usepackage{setspace}
\onehalfspacing
\usepackage{seqsplit}
\usepackage{hhline}

\bibliography{bibliography}


%%%%%%%%%%%%%%%%%%%
%% definitions
%%%%%%%%%%%%%%%%%%%
\def\BaAuthor{Achim Winter}
\def\BaAuthorStudyProgram{Computer Science}
\def\BaType{Bachelor thesis} %% is this correct?
\def\BaTitle{Operating a Smartphone as a Hardware Security Module}
\def\BaSupervisorOne{Prof.\ Dr.\ Junker-Schilling}
\def\BaSupervisorTwo{Prof.\ Dr.\ Huffstadt}
\def\BaDeadline{\today}

\ifdefined\iswithfullname
  \def\ShowBaAuthor{\BaAuthor}
\else
  \def\ShowBaAuthor{N.~N.}
\fi

\hypersetup{
pdfauthor={\ShowBaAuthor},
pdftitle={\BaTitle},
pdfsubject={Subject},
pdfkeywords={Keywords}
}

%%%%%%%%%%%%%%%%%%%
%% configs to include
%%%%%%%%%%%%%%%%%%%
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  showstringspaces=false,
  commentstyle=\color{gray}\upshape
  linewidth=\textwidth
}

\usepackage{array}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}   % center
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}} % left
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}  % right
%\newcolumntype{w}[1]{>{\raggedleft\hspace{0pt}}p{#1}}

\lstset{language=Java,
  showspaces=false,
  showtabs=false,
  tabsize=4,
  breaklines=true,
  keepspaces=true,
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  backgroundcolor=\color{background},
%  moredelim=[il][\textcolor{pgrey}]{$$},
%  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\newcommand*{\forcetwosidetitle}[1][1]{%
 \begingroup
   \cleardoubleoddpage
   \KOMAoptions{titlepage=true}% useful e.g. for scrartcl
   \csname @twosidetrue\endcsname
   \maketitle[{#1}]
 \endgroup
}


\begin{document}


%%%%%%%%%%%%%%%%%%%
%% Titelseite
%%%%%%%%%%%%%%%%%%%


\frontmatter
\titlehead{%  {\centering Seitenkopf}
  {University of applied Sciences W\"{u}rzburg-Schweinfurt\\
   Faculty of Computer Science and Business Informatics}}
\subject{\BaType}
\title{\BaTitle\\[15mm]}
\subtitle{\normalsize{submitted to the University of Applied Sciences W\"{u}rzburg-Schweinfurt in the Faculty of \BaAuthorStudyProgram}}
\author{\ShowBaAuthor}
\date{\normalsize{Submitted on: \BaDeadline}}
\publishers{
  \normalsize{First Supervisor: \BaSupervisorOne}\\
  \normalsize{Second Supervisor: \BaSupervisorTwo}\\
}
%\lowertitleback{
% \centering\includegraphics[width=4cm]{qrcode-thesis.png}

%}
\forcetwosidetitle


%%%%%%%%%%%%%%%%%%%
%% abstract
%%%%%%%%%%%%%%%%%%%

\section*{Summary}
TODO

\section*{Abstract}

TODO

\newpage
\chapter*{Acknowledgment}

I would like to thank Prof. Dr. Junker-Schilling for his helpful support. The seminars and the discussions with the other students helped me a lot to stay on schedule and make the work what it is now. My further thanks go to Prof. Dr. Huffstadt for the second correction. 

I would also like to thank Francis Pouatcha and Steffen Blümm for their support from adorsys. The discussions always brought new ideas on how the work can be further improved. Thank you very much for that.

I would also like to thank my proofreaders and my family. Thanks to you too, the work has become what it is today.

%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis
%%%%%%%%%%%%%%%%%%%
\tableofcontents



%%%%%%%%%%%%%%%%%%%
%% Main part of the thesis
%%%%%%%%%%%%%%%%%%%
\mainmatter

\chapter{Introduction}\label{ch:intro}

The two main fields of cryptography in computer systems can be divided between symmetric-key cryptography and public-key cryptography. Symmetric-key utilizes the same key for the sender and the receiver, which was the first form of encryption and also secure and easy to understand. If this is done by close relatives this may be possible, but exchanging this key to every website when browsing through the internet is impractical. Not only because it is physically nearly impossible, but also because the amount of keys one would have to store securely would be growing by the square of number of communication partners.
% Maybe a picture for symmetric encryption
To avoid this kind of key management, Whitfield Diffie and Martin Hellman published a system in 1976 known as the public-key cryptography. With this system it is possible to generate an encryption key over an insecure network such as the Internet in order to secure subsequent communication. However, the real encryption key is never transferred to the opposing communication partner. In fact the real encryption key is being calculated by using public and private keys, which have a mathematical relation to each other. Each communication partner has to create a pair of his own private and public key. While the public key can be exposed to the Internet, the private key has to remain secret. 
By using both key pairs, a common shared key can be calculated which then can be used for the encryption. This system relies on the computational complexity, such as prime factorization, which is hard to do with big numbers. 
%[Was ist der Diffie-Hellman-Schlüsselaustausch?] [https://en.wikipedia.org/wiki/Cryptography#Computer_era]

The usage of encryption when visiting a web page has grown from about 30\% in 2014 to about 80\% by the end of 2019

\begin{figure}[ht]
	\centering
  \includegraphics[width=0.8\textwidth]{ressources/https_statistics.png}
	\caption{Percentage of Web Pages Loaded by Firefox Using HTTPS \parencite{letsencrypt_lets_2019}}
\end{figure}

This could come due to several reasons. Whistleblower Edward Snowden has received a lot of media interest and has made people aware of using secure services on the Internet, when he revealed the capabilities of the National Security Agency (NSA). In addition, browser manufacturers like Mozilla or Google warn their users when they visit a website without HTTPS with an open red lock next to the address bar.
% Quelle NSA Snowden, http = unsecure google


\section{Motivation}

The use of public/private keys is too troublesome for many people, even IT professionals. The manual distribution of keys between several devices becomes more difficult the more devices there are. However, end-to-end encryption is only possible if multiple devices have the access to the same private key. The synchronization of private keys is often done via cloud providers, although they are also often attacked. The keys would either have to be additionally encrypted, which makes handling more difficult again, or distributed in another way. On the other hand, systems such as Android or iOS offer more and more security features in their latest versions, such as the generation of random numbers in their own encapsulated processor. It is therefore worth investigating to what extent this can be used to simplify the handling of private keys.


% \subsection{Entrepreneurial perspective}

% The adorsys GmbH \& Co. KG is a software development and consulting company that specializes in the fields of banking and insurance, but also develops software for industry companies. That's why internal security is especially important for adorsys and therefor also the security of communication within the company. Employees usually also have a smartphone that accesses corporate services. The management of key pairs, for example for secure email communication, is very important. 

% \subsection{Social perspective}

% The principles of private/public keys are 
% Secure email communication is also a rarity in the private environment. Even signatures, the certainty that the person who sent me the email is really who he claims to be, is usually not given. 
% One reason for this is that email communication was never developed to be secure. On the other hand, the key management and use for many is far too cumbersome. 

\section{Objective}

The goal of this work is to use a smartphone as a kind of secure wallet to store private keys on it. The private keys should never leave the smartphone. However, the smartphone must make the services of the private keys available to other applications, such as an email client on a desktop computer, so that encrypted emails can be read from there.

\section{Environment}

The work was carried out in cooperation with adorsys GmbH \& Co. KG. Founded in 2006, adorsys primarily offers software services in the banking and insurance industries. Adorsys became particularly well known through the open source implementation of the PSD2 payment directive, which came into force in 2019. The largest customers include Teambank AG, Datev eG, Bankverlag and ERGO Direkt. Adorsys has thus built up expertise in the financial sector, where security plays a major role. 

\section{Structural Overview}

\chapter{Approach}

\section{Analysis of the current situation}

First, it is necessary to examine how keys are currently handled and their most common uses, where the end user needs to be able to access the keys. Use cases like the Diffie-Hellman should be excluded. 

\section{Requirements for Key-Distribution Systems}

After the frequent use cases have been identified, an analysis can be made of the requirements they place on key management. 

\section{Concept}

From the results of the requirements, a concept can be worked out how different systems can work together to best meet the requirements and provide the user with the best possible user experience. 

\section{Implementation}

With the help of the concept, a prototype can then be developed in the Implementation chapter, which fulfills the main functions of the concept exemplary. The findings that become visible during the development of the prototype can then be used to further improve the result of the work.

% Wahrscheinlich sollte man noch GRPC erklären
\chapter{Fundamentals}

\section{Quick-Response Codes}

Quick Response Codes (QR-Codes) are a kind of further development of barcodes, as they can be found on many products. Compared to barcodes, QR codes offer two dimensions instead of just one, which enables readers to read the codes faster and more robustly from different perspectives, but also contain more data. When a QR Code reader starts to analyze the code, it first calculates the ratio between the dark and light areas and then eliminates any possible distortion. Then the modules can be viewed, holding data ready to be used again. \parencite{office_masahiro_1994}

\section{Certificate Authority}
\label{sec:CA}

A Certificate Authority (CA) is an organization that creates digital certificates. The CA establishes a connection between a person or an organization and a public key. To create this connection, the CA must be able to check and confirm the identity of the person/organization. The public key is then signed, which allows other entities that trust the CA to be sure that it is the specified person/organization.
\parencite{luber_ca_2018}

\section{Certificate Signing Request}
\label{sec:CSR}

To have a certificate signed where a key pair already exists, a Certificate Signing Request (CSR) can be created. The advantage is that the private key does not have to be transferred to a CA but can remain secret. To do this, the customer must create a CSR to which information such as the common name (CN) is added. The CSR can then be signed with the customer's private key and sent to a CA to be signed. The CA then creates a digital certificate that the customer can distribute to communication partners.
\parencite{publico_ssl-grundlagen_2017}

%\section{Phishing}

\section{S/MIME}
Secure/Multipurpose Internet Mail Extensions (S/MIME) is one of the two main ways, how mail encryption can be accomplished. It is based on public-key cryptography. S/MIME can also be used to sign mails in order to clearly identify the sender of the message and also ensures, that the messages has not been manipulated, 
else this is easily possible and has already led to great damage through phishing attacks in the past. 
However, if the mail is only signed instead of encrypted, it can still be read by anyone who receives the data. \parencite{villadiego_dangers_2017}

S/MIME can also be classified into four different classes. The higher the class, the more certain the recipient can be that it is really the person in question.
\begin{itemize}
    \item Class 1: The CA only assures the authenticity of the mail address.
    \item Class 2: In addition to class 1, the name of the person and, if applicable, the company
    \item Class 3: Data provided from class 2 are confirmed by official documents.
    \item Class 4: Applicants must be physically present when the application is submitted
\end{itemize}

SMIME certificates can be signed by multiple Certificate Authorities. There are two possibilities for signing the keys. The first is that a Certification Authority gets the order to generate a new key pair, then sign it, hand it over to the customer and delete the keys (especially the private key) after completion. However, the customer cannot verify that the private key has been deleted or has not been copied before, so he cannot be sure that only he is in possession of the private key. The other possibility is to generate the keys locally and create a Certificate Signing Request as explained in section \ref{sec:CSR}.
\parencite{luber_smime_2018}

According to the principle of public-key cryptography, the private key of a user is used for signing and decrypting and the public key for encrypting and verifying a message.


\section{Elliptic Curve Cryptography}

Elliptical curve cryptography (ECC) is also based on the system of public-key cryptography. In comparison to other public-key cryptography systems such as RSA, algorithms that work with elliptic curves require a smaller key length, which requires less computing power, but provide the same level of security. It can be used for creating and verifying signatures, but not for encryption. However, it can be combined with a Diffie-Hellman Key Exchange. In this way, encryption can also be implemented.
\parencite{hankerson_elliptic_2011}

\subsection{DH-Key Exchange using ECC}
The security is based on the fact that the addition of several points in a coordinate system is easy, but their division is much more difficult. To perform a key exchange, both parties must commit themselves to a predetermined elliptical curve and select a random point on it that intersects the curve. From this point, a tangent can then be constructed that intersects the curve at a new point. This point is then mirrored over the X axis and selected as the new starting point. Both parties repeat this procedure very often. The number of passes is then used as a private key. The resulting point (with its x and y values) is the public key that can be transmitted to the communication partner. Afterwards both parties repeat the calculation of the tangents and the corresponding points with the number of passes of their private key. Finally, both should come to the same end point, which is then the shared secret.
\parencite{hankerson_elliptic_2011}
% Vielleicht eine andere Quelle 
\begin{figure}[ht]
 \centering
 \includegraphics[width=0.8\textwidth]{ressources/ecc.png}
 \caption{Elliptic Curve Key Generation \parencite{uszak_elliptic_2017}}
 \label{fig:ecc}
\end{figure}

However, there are concerns that a back door has been built into one of the random number generators, on a curve which was created by the NSA (NIST-P256). Other curves that are not based on this are considered secure. 
\parencite{schneier_essays_2007}

% Vielleicht dass NIST-P-256 schlecht ist in die eigentliche Arbeit 

% \section{Secret Sharing}
\section{ARM TrustZone}
\label{arm:TrustZone}

The ARM-TrustZone is an implementation for a Trusted Execution Environment (TEE) for ARM-Cortex based processors, which is the standard for mobile phones. It is a technology, which creates two environments, a trusted and a non-trusted, simultaneously on a single core. In each of the environments an own operating system is running. Software can run either in the trusted environment or the non-trusted. However, both environments can work together. For example an application running in the non-trusted environment can use a library which is running in the trusted environment. So, the TrustZone allows the secure storage of sensitive information like biometric information or Digital Rights Management (DRM) material, even if applications in the non-trusted environment are compromised.
\parencite{fowler_trustzone_2017}

\section{Hardware Security Module}
\label{sec:HSM}

A Hardware Security Module (HSM) is a peripheral device which, depending on the model, performs cryptographic functions for another computer system. This may include: Securely generating or managing cryptographic keys, protecting signatures and identities or establishing secure communication channels. It is important to note that the system using the functions of the module has no influence on the module, but can only call the functions. Such modules range from small USB tokens, such as the Ledger Nano S for crypto currency storage, to stand-alone servers that perform these cryptographic functions for a complete data center and are in addition certified for e.g. GDPR or HIPAA. As the name suggests, an HSM has separate hardware, as opposed to a Trusted Execution Environment as implemented by the ARM TrustZone. This usually consists of a CPU, separated secure storage and a generator for random numbers.
\parencite{sustek_hardware_2011}
% \parencite{ibm_hardware_2020} \parencite{gemalto_safenet_2020} 
% \section{Secure Element}

\section{Android Keystore System}

The Android keystore is a secure environment that is used to store keys and prevent their extraction as much as possible. To prevent extraction, the Android keystore follows several paths. Firstly, it gives the possibility to link the key to a secure hardware element if it supports the key type. Secondly, the actual application never has full access to the generated key. If the application wants to perform cryptographic operations like signing, encrypting or decrypting, this does not happen inside the application, but the application requests the keystore to perform the requested operation. The keystore can also be used to specify exactly which applications should have access to the keystore. So if an app is compromised, the attacker can only perform the same operations as the user did before. For example, if an attack has taken place and countermeasures have been taken, it is ensured that the attacker cannot do operations with the key anymore. 
\parencite{google_android_2020}

\subsection{Hardware Backed Keystore}
\label{android:HWB}

With the different Generations of Android Versions, the Keystore System also has evolved. While Smartphones certified for Android Versions prior 'Marshmallow' (Android Version 6.0) only supported the creation of signatures, verification and generating/importing of asymmetric keys, newer versions (> Android 6.0) also support the usage of symmetric keys. In addition, the keys can be generated with hardware support if the device has an implementation of the \nameref{arm:TrustZone}. This is always the case if the device contains a fingerprint scanner or has access to DRM material. The device can then perform cryptographic operations with the help of the keystore.
\parencite{google_hardware-backed_2020}
% Quelle für Fingerprint 


\subsection{Strongbox Keystore}

As an extension to the \nameref{android:HWB}, Google introduced a new security feature in Android Pie (Android Version 9.0), the StrongBox Keystore. The addition is, that the kind of Keystore implementation is specified by Google. With the \ref{android:HWB} every mobile phone manufacturer can implement their own TrustZone. Also, the StrongBox must operate on separated hardware to fulfill the specifications of a \nameref{sec:HSM} and to increase the security level by using dedicated hardware.

%% HW-Backed = various implementations like TrustZone
%% StrongBox = separated hardware

\section{iOS Keychain}

The iOS Keychain helps developers and users to store passwords or other sensible information. But also keys, or things like certificates. There is also a built-in password manager that is designed for the user. The way it works is, that a secret which has to be stored gets packaged in a keychain item. Additionally, there should be packaged public attributes like a name or an identifier to make the item searchable. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\textwidth]{ressources/apple_keychain.png}
  \caption{Apple Keychain \parencite{apple_keychain_2020}}
  \label{apple:keychain}
\end{figure}

It is an encrypted file in which all information that is particularly worth protecting is stored. In addition, this file can be synchronized via iCloud, Apple's cloud service, to make it available on all devices of a user. Particularly for the iPhone, every App can create its own keychain. Access to the Keychain can be additionally secured by authentication methods like FaceId or TouchId.

However, this means that the key was handled to some point in plaintext in the phone's memory, which could lead to a compromised key, if the app is also compromised. Apple created the Secure Enclave, which is a coprocessor doing cryptographic operations. This way, the key never leaves the Secure Enclave and makes it harder for an adversary to compromise the key.
Apple has implemented this feature for all smartphones with an A7 processor chip or higher.
\parencite{apple_keychain_2020}

% \subsection{Common Crypto}

\subsection{iOS Secure Enclave}

Alike the \nameref{android:HWB}, the Secure Enclave is a coprocessor, which runs cryptographic operations. In addition, it is in possession of an own random-number generator, memory, operating-system and an encrypted storage. Thus, it can securely store keys, even if the kernel of the smartphone has been compromised. Also, cryptographic keys are never exposed to applications or the operating system of the main processor.
\parencite{apple_storing_2020} 

\subsection{Apple CryptoKit}

Since Version 13.0, Apple introduced a new cryptographic API for developers, the CryptoKit. The intention behind this is to simplify the use of cryptographic functions for developers. The most important functions are the generation and comparison of secure digests, public-key cryptography for digital signatures, as well as the execution of DH key exchange and the generation and use of symmetric keys. Also, it is possible to use private keys which are managed and generated by the Secure Enclave.

% \subsection{Security Framework}

% available from iOS 13+ upwards

% secure digest

% uses secure enclave in background

\section{Signal-Protocol}

The signal protocol was developed by the Open Whisper Systems Foundation for their own messenger service Signal. It is an open standard end-to-end encryption protocol. The mayor benefit compared to other end-to-end encryption protocols is that messages can be sent encrypted even if the recipient is not online. This was also the reason for other messenger services such as WhatsApp, Skype or Facebook Messenger to implement a customized version of this encryption. 
\parencite{protocol_introducing_2018}



%\parencite{cohn-gordon_formal_2017}
% Quelle dafür das andere das auch eingebaut haben.


% Seitenzahl benoetigt wenn die komplette Arbeit daraus besteht?

\subsection*{Key Distribution Center}
\label{subsec:KDC}

In the Signal App, the Key Distribution Center exists to allow users to upload a bunch of keybundles so that they can be used by other users. In addition, messages that cannot be delivered at this point, because e.g. the receiver mobile phone is switched off, are stored there temporarily until they can be sent.

\subsection{Key Agreement Protocol - Extended Triple Diffie-Hellman}
The Key Agreement Protocol knows three parties. Alice, who would like to talk to Bob, Bob who wants other parties like Alice allow communicating with him and a server, which acts as the \nameref{subsec:KDC}. The keys needed for this key exchange are as follows:
\begin{itemize}
  \item Alice's identity key $   (IK_{A})  $
  \item Alice's ephemeral key $   ({EK_{A}})  $
  \item Bob's identity key $   ({IK_{B}})  $ 
  \item Bob's one-time prekey $   ({OPK_{B}})  $
\end{itemize}

Each of these keys is a key pair generated using elliptic curves (X25519 or X448). Though each of Bob's one-time prekeys can only be used once and Alice's ephemeral key is generated anew in each key exchange run.

The Key Agreement Protocol is build upon the Diffie-Hellman (DH) Key Exchange Protocol. However, the Extended Triple Diffie-Hellman (X3DH) is using three phases of the Key Agreement:
\begin{itemize}
  \item Bob uploads his identity key and several prekey bundles to a server.
  \item Alice requests one prekey bundle of Bob from the server.
  \item Bob receives a message from Alice and processes it.
\end{itemize}

After Alice receives the prekey bundle from the server, she checks the signature of the prekey. In the case that the signatures do not match, the protocol is aborted.
Otherwise, she generates an ephemeral key pair by using her own public key. Using this ephemeral key she can calculate a shared key (SK). After calculating the SK, she deletes the private ephemeral key and the DH outputs. Eventually, she calculates an associated data byte sequence which contains the identity keys of herself and Bob.
Finally, she can generate a message containing following keys:
\begin{itemize}
  \item Alice's identity key $    (IK_{A})  $
  \item Alice's ephemeral key $   {EK_{A}}  $
  \item An identifier which of the prekeys Alice used
  \item An initial ciphertext encrypted by the calculated shared key.
\end{itemize}

By receiving the message, Bob tries to decrypt the ciphertext by loading his identity key and the used prekey with the identifier send from Alice. With this information, Bob can repeat the calculations which were done by Alice and check if the results match and deletes the DH outputs. If not, he deletes everything he received and aborts the communication. If it was successful, he also deletes the used prekey for forward secrecy and can then use the SK for further encryption/decryption. 
\parencite{marlinspike_x3dh_2016}

\subsection{Double Ratcheting Algorithm}

The Double Ratchet Algorithm as used in the Signal-Protocol is a Key Derivation Function (KDF) algorithm, which is used to exchange encrypted messages by using a previously known SK. This SK can be generated by using some sort Key Exchange e.g. 3XDH, but outside this scope also by every other Key Exchange. As illustrated in the figure of the \nameref{fig:ratchet}, the KDF can only produce keys for other following steps, but not previous steps.

\begin{figure}[ht]
	\centering
  \includegraphics[width=0.8\textwidth]{ressources/ratchet.png}
  \caption{Mechanical Ratchet \parencite{pawl_rachet_2020}}
  \label{fig:ratchet}
\end{figure}
%Quelle für Bild (Wikimedia)

By using this algorithm, the generated keys would rather seem random to an adversary, if he doesn't know about the KDF-keys. Also, if gets in possession of one of the KDF-keys, older and future keys would also appear random to him. Using this algorithm, three different key chains are in use. A root chain, a transmitter and a corresponding receiver chain, which are the same on the opposing sides (Alice receiver chain is the same as Bob's transmitter chain and vice versa). Also, the corresponding chains have to start at the same point and have to be synchronized. Figure \ref{fig:KDF_Chain} shows, how the chains are generating keys. The output key can be used to encrypt data, the KDF-key is used to calculate the next chain element.
\parencite{perrin_double_2016}

\begin{figure}[ht]
	\centering
  \includegraphics[width=0.8\textwidth]{ressources/kdf_chain.png}
  \caption{KDF Chain \parencite{perrin_double_2016}}
  \label{fig:KDF_Chain}
\end{figure}

\subsubsection{Symmetric-key ratchet}

With the Symmetric-key ratchet, each message is encrypted with a unique message key. The message keys are generated with every ratchet step. In addition, a chain key is generated, which then can be used as a KDF key for the ratchet step. The input, which can also be seen in figure \ref{fig:KDF_Chain}, is always a constant in the Symmetric-Key Ratchet, which means that if an attacker comes into possession of a chain key and the constant, he can decrypt subsequent messages. The message keys only ensure that each message is encrypted with a unique key and can theoretically be deleted after receiving the message. In addition, however, the respective keys contain a counter that allows the matching key to be found for the message, which could by possibility not arrive in the order, in which they were sent. Though, there is no security flaw in storing these message keys, because they are not used to generate other keys.
\parencite{perrin_double_2016}

\subsubsection{Diffie-Hellman ratchet}

If an adversary could steal the transmitter and receiver chain keys, it would be possible for him to decrypt all messages in the future. To prevent this from happening, the Double Ratcheting Algorithm combines two different types of KDF chains. While the transmitter and receiver chains are based on symmetric keychains, the root chain is a DH ratchet. The transmitter and receiver chains both use a DH-keypair from the root chain as starting point. With each message the Symmetric-key ratchet are extended by one chain link. However, to ensure security for messages in the future, the symmetric keychains' actually constant values are updated with the values from the DH ratchet, causing them to be reset. The root chain can always create new transmitter and receiver chains with new public keys. In the default implementation this happens with every message.
\parencite{perrin_double_2016}

%\chapter{Problem definition}

\chapter{Analysis of the current situation}

When designing a new type of key management, it is important to look at the current solutions and their characteristics. This helps to have a better overview of the functions required in the concept. In addition, the concept should also provide a way to make it as easy as possible for the user to use his keys on several devices and at the same time to have a simple administration of them. On the other hand, this step is also necessary to identify the problems of previous solutions so that they can be addressed in the concept. In a subsequent evaluation, the best solution in terms of security, usability and the required trust in third party providers can then be evaluated in various categories.

\section{Use Cases for distributed Keys}
In this section some possible applications are presented, where a secure storage of secrets is necessary. 

\subsection{Email}

One of the most used and oldest communication channels on the Internet is e-mail. A great advantage, especially in the early days of the Internet, was that messages could be sent asynchronously. This means that the recipient could retrieve the message even if he or she was not online when it was sent, since the messages can be stored temporarily on a server. However, the e-mail is more like a postcard than a letter. Anyone who receives it can also read it, since no form of encryption is provided. Nevertheless, important and confidential information is exchanged via this medium. In order to ensure the confidentiality and integrity of the messages, protocols such as SMIME or PGP were developed. These can ensure confidentiality by means of end-to-end encryption or integrity by means of a digital signature. Both solutions use the principle of public-key cryptography. However, even today most e-mails are neither signed nor encrypted, which is mainly due to the complicated setup. 

In May 2018, there were major reports of the so-called E-Fail vulnerability, which affected both PGP and SMIME. Besides the outdated standards, a major reason for the vulnerability was that in many mail clients the display of HTML elements and the reloading of elements is enabled by default. In the meantime, the vulnerabilities have been fixed for both PGP and SMIME, so that both are again considered secure.

The creation of the key pairs is somewhat complicated for both standards. They are usually created offline on a local computer and must then be distributed to all computers that need access to them using one of the methods from \ref{sec:distribution}. Another possibility, as briefly mentioned in the basics, is to have the keys generated by a Certificate Authority, after which the keys must be distributed accordingly.

% Vielleicht welche Hilfestellungen es dazu gibt.

\subsection{SSH}
SSH is a protocol that is mainly known through the remote administration of other computers and was also developed to replace other protocols like telnet.  Beyond that, it is an independent, encrypted network protocol. It also allows other protocols like HTTP to be tunneled through SSH connections, which is practically equivalent to a VPN. Other protocols such as SCP for data transfer or Git as a distributed version management system are also based on it or use SSH for authentication. 

The authentication is ideally done with public and private keys. Alternatively, authentication via a password can also be implemented. 

According to the report by Edward Snowden, the NSA is partially able to decrypt SSH connections.

In most cases, a separate key can and should be generated for each device in the case of SSH. The distribution of the keys can therefore be disregarded here.

% Git und die eigentlichen SSH Verbindungen
% bei GIT: Sowohl authentifikation als auch verschlüsselung dank SSH

\subsection{Password Manager}
Passwords are one of the most widely used types of authentication mechanisms on the Internet. Nearly every service uses them to verify that the user is the specified user by knowing that only the authorized user should have access to them. The problem that emerges is that there are many users who use weak passwords or who use the same password for several services. Both of these are security risks. Therefore, there are password managers that are able to generate passwords securely and release them only with access to a master password and/or key file. The passwords of the services are stored in databases that are encrypted with the master password/keyfile.

To be able to use all services on all devices, the database must be distributed on several devices in the case of an offline password manager that does not store the data on the provider's servers. If a keyfile is used, it must also be securely distributed to multiple devices.

\subsection{Multi-factor authentication}
The multi factor authentication is an extension of the authentication as explained in the previous chapter by the password. In addition to the knowledge that an user must have in order to log in, the ownership of another device, for example, can be used as an additional authentication factor. 

\subsection{Crypto Currencies}
The principle of public-key cryptography is also used for cryptocurrencies like Bitcoin. This is used to generate signatures for transactions. 

The public key represents the receiving address, similar to the IBAN in bank communication. It can also be used to encrypt messages that only the recipient should be able to read. As a rule, however, there is not only one public-private key pair, but several, which are combined under a master key that encrypts all others as with the password manager. It is beyond the scope of this paper to look further into the background of the Master Key. However, if several devices are to have access to the money, the master key must be distributed to several devices.


\section{Distribution of private keys}
\label{sec:distribution}

\subsection{Local/Offline}
For example, to transfer a private key from one device to another, a USB cable can be used. For devices such as smartphones, a normal cable can be used for this purpose, which is also used to charge the smartphone. If you wish to transfer a private key from a desktop computer to a laptop, for example, you must use a connection cable to enable the transfer.
% Quelle mit Linkkabel

\subsubsection{USB stick}
Another way to exchange data securely could be the use of an USB stick, whereas this solution is more suitable for two different computers than the connection with smartphones. If the USB stick is trustworthy, there is no danger for the respective computers and the key can be transferred in this way. However, it should be noted that the data of the key is still stored on the USB stick, even if the key has been deleted on the computer. The memory cells are only marked for deletion and not directly overwritten. The data can be reconstructed with special software. As an additional security measure one could pack the key into an archive and protect it with a password. However, there is also the attack vector that attackers who come into possession of the USB stick can find out the password with a dictionary attack or brute force.
% Quelle Brute Force && Dass Daten nur zum löschen markiert werden.

\subsection{SCP}
As already mentioned, SCP is a protocol for exchanging data securely via SSH. It could also be used to transfer the private key. A positive aspect is that the connection is automatically encrypted and, compared to USB sticks, no data is left over that an attacker could use. The disadvantage is that you have to set up SSH first, which is still easy on MAC or Linux computers. However, on iPhones it does not work without a jailbreak. The alternative for iPhones would be Airdrop, which is a proprietary protocol from Apple and not available on Linux and Windows machines. How easy it is to use therefore depends on the devices that are supposed to participate in the communication. In addition, there is the risk that, as mentioned, the NSA can partially decrypt SSH connections.

\subsection{Webservers/Downloads}
The possibility to create the private key at a Certificate Authority also provides the potential to download it once on all devices via the web server of the Certificate Authority. Since the connection is protected with HTTPS, this is also secure and user-friendly, since no separate servers have to be set up beforehand to start the file transfer. For this kind of transfer only the known attacks for HTTPS would work, but these are not considered further in the context of this work.

\subsection{External Providers}
Last but not least there is the possibility to synchronize the private key with cloud providers like Google Drive or Dropbox on the different devices. However, this requires a great deal of trust in the cloud providers. In doing so, the legal regulations of the respective countries of origin must also be observed.
The user-friendliness is very high, and the security is similar to that of web servers, as the transmissions are usually secured with HTTPS. In addition, there is also the risk that the login data can be tapped by means of phishing. Once the key has fallen into the hands of criminals, it is no longer usable. The biggest shortcoming, however, is the great trust that must be placed in the cloud provider. 
% https://de.wikipedia.org/wiki/USA_PATRIOT_Act#Auswirkungen_auf_den_Schutz_personenbezogener_Daten_und_geistigen_Eigentums


\chapter{Requirements for Key-Distribution Systems}
In order to create a new type of key distribution system, it is necessary to analyze what requirements are placed on such a system. For this purpose, the use cases are used to filter out an intersection of the requirements, which should then represent the cornerstones of the new application.

\section{Usability}
As the use cases have shown, a solution for the distribution of secrets must above all be user-friendly. If you take a closer look at SCP, you will notice that it can only be used very differently on different operating systems and platforms or only with massive intervention in the system. The most convenient solution is therefore the cloud. Here, any device can access and use the secrets, with minimal set-up effort for the user.

% Welche Kriterien gibt es für die usability
\section{Security}
If you consider security, SCP is the best choice. The secrets are directly encrypted here, there are no remnants and no other parties involved. Both devices only need to be on the same network. The web server and cloud solutions are also technically secure. However, third parties must be trusted to keep the secrets secret. 

Enter a passphrase on computer and then on mobile phone would add security but isn't that convenient.

%\section{Loss Coverage}
% Kommt nur in ausblick
\chapter{Concept}
The aim of this chapter is to use the previous analyses to develop a concept that facilitates the distribution of secrets.

\section{Architecture}
\begin{figure}[ht]
	\centering
  \includegraphics[width=0.8\textwidth]{ressources/process_flow.png}
  \caption{Application Flow (self-created representation)}
  \label{fig:app_flo}
\end{figure}
The figure shows the basic flow of the application. The Third-Party Application displays the fngerprint of his identity key in a QR-Code, which the smartphone can scan. Using the fingerprint, the smartphone can then request a PreKeyBundle from the Key Distribution Center. At the same time, it is used to check whether the PreKeyBundle really comes from the scanned QR Code, since it is signed with the Identity Key. If this check fails, the smartphone terminates the communication. Otherwise the smartphone can use the PreKeyBundle to create a PreKey Message which can be processed by the desktop application to establish a session. After these steps have been successfully completed, the application can make regular requests to the smartphone to perform cryptographic operations.

\section{Signal Protocol}
After an evaluation, as shown in \ref{tab:crypto_eval}, it has been found that the signal protocol is best suited for such an application. A classical secure connection like in a client-server model, for example with https, would not be appropriate, because then more trust has to be put back into the server in the middle, which establishes the connections of the clients. Therefore, only protocols that offer end-to-end encryption can be considered. 
\begin{table}[ht]
    \centering
    \setlength{\colw}{0.15\textwidth-2\tabcolsep}

    \begin{tabular}{L{0.39\textwidth-2\tabcolsep}||C{\colw}|C{\colw}|C{\colw}|C{\colw}}
        & \textbf{Weighting}& \textbf{Signal-Protocol} & \textbf{SMIME} & \textbf{OTR}  \\
        \hhline{=::====} Usability &
        3 & 2 & 1 & 2 \\
        \hline Platform independent & 2 & 3 & 3 & 2\\
        \hline Scalability & 1 & 3 & 3 & 3 \\
        \hline Verifiable security & 3 & 3 & 2 & 2 \\
    \end{tabular}
    \caption{Evaluation of the cryptography protocols}
    \label{tab:crypto_eval}
\end{table}
The usability of the protocol is very important for the application, as plugins have to be written for various third-party applications, which then communicate with the app on the smartphone. The developers of these plugins should therefore be made as easy as possible. With the signal protocol, there is a simple guide for the implementation, and once the classes for storing the secrets are written, a connection can be established with a few lines of code. With SMIME, the certificates would have to be signed first, as before, or signed by everyone themselves, which would require separate keys for a Certificate Authority. Compared to Signal, OTR does without the Key Distribution Center, which is an advantage in this case, since no asynchronous communication is necessary anyway. However, there is no official implementation of the protocol and most of the existing ones are mostly developed by one person.
The signal library is available for Java, C and Javascript. SMIME is based on OpenSSL, which is also available on every system. OTR lacks an implementation for the Web, that is, Javascript.
Scalability plays a rather subordinate role in this application, as there are only 1:1 connections. However, intermediate stations, as required by the signal protocol, should not become a bottleneck. Considering the millions of users who use Whatsapp, which uses the signal protocol as mentioned, there are no problems here.
Since secrets are to be transferred via the application, it is important that the protocol can be checked for security by independent researchers and that it passes this check.
With the signal protocol, there is a risk of a man-in-the-middle attack if the fingerprint is not verified. In addition, an Unknown Key Share attack may occur. To exploit this, an attacker would have to be able to present his own QR code to the smartphone. This attack can only be minimized by additional information in the fingerprint, such as a clear name, telephone number or similar, but cannot be prevented. SMIME had problems in the past with the E-Fail gap, which has been closed. However, the entire communication is readable for an attacker as soon as he knows the victim's private key.


% Hier könnte ihre Evaluierung stehen. 
% Anbieter für End-to-End Encryption:
% Signal, OpenPGP, S/MIME, OMEMO, Telethon (Telegramm)
% Bei SSL gäbe es das Key Distribution Center dazwischen. 
% Außerdem nicht 
% Signal anfällig für Unknown Key-Share Attack --> Wird das durch Fingerprint behoben? Evtl. Francis fragen.

\section{gRPC}
The way the architecture of the application is constructed suggests that the smartphone represents the server role, as it provides the cryptographic services. However, this would mean that the third-party application would make the request for decryption to the smartphone. But it cannot do this, because it does not know the address of the server. While it would theoretically be possible, after scanning the QR code containing the identifier, to send a notification from the server to the third party application with the address of the smartphone, this increases the complexity and the standard implementation of the signal server has to be adapted additionally. Instead, it is easier for the third-party application to create a server and the smartphone can access it. As you can see in Figure 6.1, however, you need a way for the server to send messages to the smartphone. This could be done through a web socket connection or gRPC. While websockets require additional manual identifiers to specify what the smartphone should do with the message, gRPC allows you to call another function directly. Therefore gRPC is very well suited for this application.

\section{Keychain/Keystore}
The keychain in iOS or the keystore in Android can be used in the application to generate keys and store them securely. For example, an RSA key can be generated that can be used for SMIME. 

However, please note that a key that was generated with hardware elements cannot be exported from the application. While this increases the security of the key on the one hand, it prevents you from making a backup of the key on the other hand. So if the app is uninstalled or the phone is lost, the key will be gone too. 
\section{Usability}
As already mentioned in architecture(ref make), the connection from the smartphone to the third-party application is established using a QR code. As soon as the smartphone has registered with the application as an HSM device, communication can already begin. If the session has ended, the connection is terminated. If a new connection is desired, a QR code must be scanned again.

\chapter{Implementation}

\section{Kotlin}

\section{gRPC}

\section{Prototype}

\subsection{App}

\subsection{Desktop Client}

% Nach dem verbinden mit QR Code könnte in der App eine Pin angezeigt werden die dann am PC eingegeben werden muss.


\chapter{Evaluation}

\section{Usability}

\section{Security}

%\section{Existing Solutions}

%\section{QR-Based Solution}

\chapter{Summary}

\chapter{Outlook}

Backup can be implemented using social secret sharing or other things when keys are generated in memory --> Not possible with secure element and thus must be made Softwareside. 

You could create clients for all kinds of desktop Programs, ssh, pgp, and so on.

\backmatter
%%%%%%%%%%%%%%%%%%%
%% create figure list
%%%%%%%%%%%%%%%%%%%

\listoffigures
\addcontentsline{toc}{chapter}{Directories}

%%%%%%%%%%%%%%%%%%%
%% create tables list
%%%%%%%%%%%%%%%%%%%
% \listoftables

%%%%%%%%%%%%%%%%%%%
%% create listings list
%%%%%%%%%%%%%%%%%%%
%\lstlistoflistings
%\addcontentsline{toc}{chapter}{Listings}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography

%%%%%%%%%%%%%%%%%%%
%% declaration on oath
%%%%%%%%%%%%%%%%%%%

\addchap{Affidavit}

I hereby certify that I have written my bachelor thesis independently and have not yet submitted it for examination purposes elsewhere. All sources and aids used are listed, literal and meaningful quotations have been marked as such.

\vspace{20pt}
\begin{flushright}
$\overline{~~~~~~~~~~~~~~~~~\mbox{\ShowBaAuthor, am \today}~~~~~~~~~~~~~~~~~}$
\end{flushright}

\addchap{Consent to plagiarism check}

I hereby agree that my submitted work may be sent to PlagScan (www.plagscan.com) in digital form for the purpose of checking for plagiarism and that it may be temporarily (max. 5~years) stored in the database maintained by PlagScan as well as personal data which are part of this work may be stored there.

\begin{small}
This Consent is voluntary. Without this consent, the plagiarism check can still take place, when all personal data is removed from the document. Consent to the storage and use of personal data may be revoked at any time by notifying the faculty.
\end{small}

\vspace{20pt}
\begin{flushright}
$\overline{~~~~~~~~~~~~~~~~~\mbox{\ShowBaAuthor, am \today}~~~~~~~~~~~~~~~~~}$
\end{flushright}

\end{document}
